<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0xff00</title>
  <subtitle>can&#39;t afford 0xffff</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://0xff00.com/"/>
  <updated>2017-09-11T10:24:47.561Z</updated>
  <id>http://0xff00.com/</id>
  
  <author>
    <name>kenbing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>幂等提交</title>
    <link href="http://0xff00.com/2017/09/07/idempotence-submit/"/>
    <id>http://0xff00.com/2017/09/07/idempotence-submit/</id>
    <published>2017-09-07T07:49:54.000Z</published>
    <updated>2017-09-11T10:24:47.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在业务开发中，我们常会面对防止重复请求的问题。当服务端对于请求的响应涉及数据的修改，或状态的变更时，可能会造成极大的危害。特别是交易系统，售后维权，以及支付系统中尤其严重。前台操作的抖动，快速操作，网络通信或者后端响应慢，都会增加后端重复处理的概率。</p>
<p>当然，前端能屏蔽掉重复请求（真的可以吗？前端同学回答下）你也无法逃避 timeout 这个噩梦，所以，既然重复提交无法避免，那我们就从其他地方入手，先看下一些简单的需求场景：</p>
<ol>
<li>前端重复提交选中的数据，应该后台只产生对应这个数据的一个反应结果；</li>
<li>我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱；</li>
<li>发送消息，也应该只发一次，同样的短信发给用户，用户会哭的；</li>
</ol>
<p>既然调用方不靠谱，网络不靠谱，那么接口提供方就必须靠谱，允许你多次调用，我的接口都能handle，这种能力就叫幂等性。</p>
<h1 id="幂等接口"><a href="#幂等接口" class="headerlink" title="幂等接口"></a>幂等接口</h1><p>幂等是一个数学概念（摘自维基百科）</p>
<blockquote>
<ul>
<li>在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。例如，乘法下唯一两个幂等实数为0和1。</li>
<li>某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的。</li>
<li>一元运算的定义是二元运算定义的特例。</li>
</ul>
</blockquote>
<p>相应地，在计算机领域，如果一个接口一次调用或多次调用的结果是一样的，那么这个接口就是幂等的。但是我没看到一个很严谨的解释，毕竟是延伸过来的说法。</p>
<p>所以还是列举下一些常见的幂等接口：</p>
<ol>
<li>HTTP GET</li>
<li>SQL SELECT</li>
<li>大家补充…</li>
</ol>
<p>不是幂等的接口</p>
<ol>
<li>HTTP POST</li>
<li>SQL UPDATE</li>
<li>大家补充…</li>
</ol>
<p>从这些简单的例子，我大胆归结下<strong>计算机领域</strong>的<strong>幂等性</strong>是：</p>
<ol>
<li>一次调用或多次调用对系统影响是一样的</li>
<li>接口返回的结果也是一样的（不受接口调用之外的影响）</li>
</ol>
<p>好了，说完接口的幂等性，它能防止重复提交，接下来讲讲一些经典的实现方案及适用场景。</p>
<h2 id="token校验"><a href="#token校验" class="headerlink" title="token校验"></a>token校验</h2><p>由 server 产生，并且存一份，再埋在form/cookies/header;<br>client 下次请求带上 token, server 校验通过后刷新 token，执行业务；</p>
<p>优点：client 改动很小甚至不需要改动<br>缺点：无法支持 client 并发请求<br>其他讨论：server如何存储token/如果用缓存如何设置key</p>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>通过把并发问题变成串行问题，如何实现很简单</p>
<ol>
<li>数据库去重表</li>
<li>redis 原子性</li>
<li>MQ</li>
</ol>
<h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">update</span> table_xxx <span class="keyword">set</span> <span class="keyword">col</span>=col_xxx, ver=ver+<span class="number">1</span> <span class="keyword">where</span> ver=ver</div></pre></td></tr></table></figure>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_xxx <span class="keyword">where</span> <span class="keyword">id</span> = id_xxx <span class="keyword">for</span> <span class="keyword">update</span></div></pre></td></tr></table></figure>
<p>具体哪种看业务对更新成本及更新频率的考量。</p>
<h2 id="状态机幂等"><a href="#状态机幂等" class="headerlink" title="状态机幂等"></a>状态机幂等</h2><p>当业务涉及到多个状态更改，如下单支付，广告创建，可以给每一步递增标记，只允许提交大于当前标记的请求，然后每一步的幂等由上诉几种方案实现。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>防止重复提交跟保障一致性相似，要看场景，没必要强求。</li>
<li>幂等性应该列入程序员必备知识，特别是做 web 开发的程序员。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.hollischuang.com/archives/934" target="_blank" rel="external">深入理解乐观锁与悲观锁</a><br><a href="http://825635381.iteye.com/blog/2276077" target="_blank" rel="external">高并发的核心技术-幂等的实现方案</a><br><a href="http://yongpoliu.com/idempotent/" target="_blank" rel="external">系统幂等以及常用实现方式</a><br><a href="http://mogu.io/prevent-duplicate-requests-4/comment-page-1#comments" target="_blank" rel="external">防重复请求处理的实践与总结</a><br><a href="https://www.zhihu.com/question/27744795" target="_blank" rel="external">分布式高并发系统如何保证对外接口的幂等性</a><br><a href="http://geyifan.cn/2016/06/02/idempotent-solutions/" target="_blank" rel="external">幂等策略分析</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在业务开发中，我们常会面对防止重复请求的问题。当服务端对于请求的响应涉及数据的修改，或状态的变更时，可能会造成极大的危害。特别是交易系统，售
    
    </summary>
    
    
      <category term="idempotence" scheme="http://0xff00.com/tags/idempotence/"/>
    
  </entry>
  
  <entry>
    <title>被浏览器缓存策略折腾的一天</title>
    <link href="http://0xff00.com/2017/07/05/browser-cache/"/>
    <id>http://0xff00.com/2017/07/05/browser-cache/</id>
    <published>2017-07-05T07:34:13.000Z</published>
    <updated>2017-09-07T07:49:10.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="故事背景…"><a href="#故事背景…" class="headerlink" title="故事背景…"></a>故事背景…</h1><p>昨天，遇到 facebook CDN 图片一个缓存策略问题，发现自己 HTTP 缓存的相关知识都忘差不多了，必须整理一下，好，整理完再看那个问题，卧槽，缓存行为完全跟规范说的不一样，求知心强烈的我陷入了 Block 模式，开始折腾这一奇怪的现象。</p>
<p>@Todo</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;故事背景…&quot;&gt;&lt;a href=&quot;#故事背景…&quot; class=&quot;headerlink&quot; title=&quot;故事背景…&quot;&gt;&lt;/a&gt;故事背景…&lt;/h1&gt;&lt;p&gt;昨天，遇到 facebook CDN 图片一个缓存策略问题，发现自己 HTTP 缓存的相关知识都忘差不多了，必须整理
    
    </summary>
    
    
      <category term="http" scheme="http://0xff00.com/tags/http/"/>
    
      <category term="cache" scheme="http://0xff00.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>分布式笔记整理</title>
    <link href="http://0xff00.com/2017/06/26/CAP/"/>
    <id>http://0xff00.com/2017/06/26/CAP/</id>
    <published>2017-06-26T14:59:59.000Z</published>
    <updated>2017-09-07T10:39:15.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式系统定义"><a href="#分布式系统定义" class="headerlink" title="分布式系统定义"></a>分布式系统定义</h1><p>想象有这样一台计算机：</p>
<ol>
<li>极其高速的CPU</li>
<li>极其宽大的总线</li>
<li>极其大容量的内存</li>
<li>极其大带宽的网卡</li>
<li>极其稳定的组合在一起</li>
<li>再连接上一条及其稳定的线路</li>
</ol>
<p>我觉得即使再贵，买这样一台单机处理能力极其强劲的服务器就可以满足大多数应用场景，可是没有，所以才有了分布式。</p>
<p>分布式是个很广泛的话题，从我十年前我刚上大学到现在，伴随着大数据及云服务，一直保持着热度，先来看看分布式系统的定义，摘自《分布式系统概念与设计》。</p>
<blockquote>
<p>分布式系统是一个硬件或软件组件分布在<strong>不同的网络计算机</strong>上，彼此之间仅仅通过<strong>消息传递</strong>进行通信和协调的系统。</p>
</blockquote>
<p>可以看出一个分布式系统应该具备：</p>
<p><strong>某博主的看法</strong></p>
<ol>
<li>分布性</li>
<li>对等性（kb注：保持疑虑，下文有讨论）</li>
<li>并发性</li>
<li>缺乏全局时钟</li>
<li>故障总是会发生</li>
</ol>
<p><strong>我的看法（再次提一下第一性原理 ;P）</strong></p>
<ol>
<li>多机</li>
<li>网络</li>
</ol>
<h2 id="解决哪些问题"><a href="#解决哪些问题" class="headerlink" title="解决哪些问题"></a>解决哪些问题</h2><ol>
<li>单机处理能力差</li>
<li>单点故障</li>
</ol>
<h2 id="带来哪些问题"><a href="#带来哪些问题" class="headerlink" title="带来哪些问题"></a>带来哪些问题</h2><ol>
<li>通信异常</li>
<li>三态 (Success/Failure/Timeout)</li>
<li>网络分区</li>
<li>节点故障</li>
</ol>
<p><strong>总的来说：网络是不稳定的！</strong></p>
<h2 id="讨论下一个场景？"><a href="#讨论下一个场景？" class="headerlink" title="讨论下一个场景？"></a>讨论下一个场景？</h2><ol>
<li>数据分区</li>
<li>数据冗余</li>
</ol>
<p><strong>问题：哪个才算分布式？</strong></p>
<h1 id="分布式系统分类"><a href="#分布式系统分类" class="headerlink" title="分布式系统分类"></a>分布式系统分类</h1><p>按我粗浅的认知，分布式系统可以归为两大类</p>
<ol>
<li>分布式计算系统</li>
<li>分布式存储系统（数据的分布及同步问题）</li>
</ol>
<p>由于对分布式计算领域缺乏了解，本文讨论范围多以分布式存储为背景。</p>
<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p>提到分布式，不得不提这三个特性：</p>
<ul>
<li><strong>C</strong>onsistency: Every read receives the most recent write or an error</li>
<li><strong>A</strong>vailability: Every request receives a (non-error) response</li>
<li><strong>P</strong>artition tolerance: The system continues to operate despite an arbitrary number of messages being dropped or delayed by the network between nodes</li>
</ul>
<p>在分布式系统中，三者不能同时满足。这就是 CAP 理论，简单地说就是：</p>
<ul>
<li>要想让数据避免单点故障，就得写多份数据（保证P）</li>
<li>写多份的问题会导致数据一致性的问题（导致C）</li>
<li>数据一致性的问题又会引发性能问题（导致A）</li>
</ul>
<p>要如何衡量取哪两者呢？看看下面这张图，产生了三个交叉系统</p>
<p><img src="cap.png" alt="cap cross"></p>
<ol>
<li>CA 放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择</li>
<li>AP 放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多 NoSQL 系统就是如此</li>
<li>CP 放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用</li>
</ol>
<p>结合分布式的特征，我们单独分析下三者的适用场景：</p>
<ul>
<li>P 是每个分布式系统基本的特征，必须保证，无法避免</li>
<li>A 是整个系统性能的考量，谁会用一个龟速还可能要超时重连的系统</li>
<li>C 这里强调的是强一致性，现实中强一致性的需求很少，只好在一致性上做妥协</li>
</ul>
<p><strong>所以在我看来</strong>，更通用的分布式系统要满足AP。</p>
<h1 id="分布式ACID"><a href="#分布式ACID" class="headerlink" title="分布式ACID"></a>分布式ACID</h1><p>ACID 在单机上，或者CP模型下实现起来是不难的，但前者是单点，后者更是损失了A，所以分布式事<br>物是整个分布式领域无法逃避的难题，下面就分布式事务的实现，从简陋到严谨，层层递进，试着阐<br>述行业内的一些解决策略。</p>
<h2 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h2><p>首先我们对C做个分类，上文提到，现实中对强一致性需求不大，我们把一致性拆解为一下三种模型：</p>
<ol>
<li>Weak 弱一致性：当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。比如：某些 cache 系统，网络游戏其它玩家的数据和你没什么关系，VOIP 这样的系统，或是百度搜索引擎呵呵（kb注：陈皓原话）。</li>
<li>Eventually 最终一致性：当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件、Amazon S3，Google 搜索引擎这样的系统。</li>
<li>Strong 强一致性：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，Azure Table 都是强一致性的。</li>
</ol>
<p>从这三种一致型的模型上来说，我们可以看到，Weak 和 Eventually 一般来说是异步冗余的，而 Strong 一般来说是同步冗余的，异步的通常意味着更好的性能，但也意味着更复杂的状态控制。同步意味着简单，但也意味着性能下降。先大概让我们来看看有哪些策略：</p>
<ul>
<li>Master-Slave</li>
<li>Master-Master</li>
<li>2PC/3PC</li>
<li>Two Generals Problem</li>
<li>Paxos/Raft</li>
</ul>
<p>一致性模型的说明，陈皓在<a href="http://coolshell.cn/articles/10910.html" title="CoolShell" target="_blank" rel="external">这篇博文</a>中已经阐述得非常清楚，强烈建议看一看！附上结论图：</p>
<p><img src="stragety_of_consistency.jpg" alt="stragety of consistency"></p>
<p>前面说过，要想让数据有高可用性，就需要冗余数据写多份。写多份的问题会带来一致性的问题，而一致性的问题又会带来性能问题。从上图我们可以看到，我们基本上来说不可以让所有的项都绿起来，这就是著名的CAP理论：一致性，可用性，分区容忍性，你只可能要其中的两个。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此，一切还是遵循着 CAP 理论，但是，据说，Google 新发布的 Spanner 关系型 NoSQL 已经打破了 CAP，欲知详情，且听下回分解，或者，你现在就可以 google 一下。</p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="https://en.wikipedia.org/wiki/Eventual_consistency" title="BASE" target="_blank" rel="external">https://en.wikipedia.org/wiki/Eventual_consistency</a><br><a href="https://en.wikipedia.org/wiki/CAP_theorem" title="CAP" target="_blank" rel="external">https://en.wikipedia.org/wiki/CAP_theorem</a><br><a href="http://coolshell.cn/articles/10910.html" title="CoolShell" target="_blank" rel="external">http://coolshell.cn/articles/10910.html</a><br><a href="http://wuchong.me/blog/2014/08/07/distributed-storage-system-knowledge/" title="Jark&#39;s Blog" target="_blank" rel="external">http://wuchong.me/blog/2014/08/07/distributed-storage-system-knowledge/</a><br><a href="http://www.cnblogs.com/xrq730/p/4944768.html" title="五月的仓颉" target="_blank" rel="external">http://www.cnblogs.com/xrq730/p/4944768.html</a><br><a href="http://www.jianshu.com/p/6cb8ffce7510" title="JeffBond" target="_blank" rel="external">http://www.jianshu.com/p/6cb8ffce7510</a><br><a href="http://thesecretlivesofdata.com/raft/" title="Raft动态演示" target="_blank" rel="external">http://thesecretlivesofdata.com/raft/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式系统定义&quot;&gt;&lt;a href=&quot;#分布式系统定义&quot; class=&quot;headerlink&quot; title=&quot;分布式系统定义&quot;&gt;&lt;/a&gt;分布式系统定义&lt;/h1&gt;&lt;p&gt;想象有这样一台计算机：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;极其高速的CPU&lt;/li&gt;
&lt;li&gt;极其宽大的总线
    
    </summary>
    
    
      <category term="distributed" scheme="http://0xff00.com/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>有用但不常用的git指令</title>
    <link href="http://0xff00.com/2017/01/11/git-tips/"/>
    <id>http://0xff00.com/2017/01/11/git-tips/</id>
    <published>2017-01-11T15:26:24.000Z</published>
    <updated>2017-03-20T01:15:24.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="暂存当前分支代码（不提交）"><a href="#暂存当前分支代码（不提交）" class="headerlink" title="暂存当前分支代码（不提交）"></a>暂存当前分支代码（不提交）</h2><p><em>场景：当你在开发分支工作，突然收到一个线上故障，需要立刻新建一个 hotfix 分支去修复，但是<br>开发分支的代码才写了一半，你不希望提交，但是强制切去 hotfix 分支又会丢失当前的代码。</em></p>
<p>这时候可以把工作目录的修改暂存起来</p>
<pre><code>git stash
</code></pre><p>当你处理完故障切换回原来分支继续干活，恢复刚刚上一次暂存的记录</p>
<pre><code>git stash apply 
</code></pre><p>又或者恢复并从暂存区删除上一次暂存的记录</p>
<pre><code>git stash pop 
</code></pre><p>另外，你可以查看暂存列表</p>
<pre><code>git stash list
</code></pre><p>恢复指定第2个暂存记录</p>
<pre><code>git stash apply stash@{2}
</code></pre><h2 id="清空工作目录的修改"><a href="#清空工作目录的修改" class="headerlink" title="清空工作目录的修改"></a>清空工作目录的修改</h2><p><em>场景：当你在工作目录做一些修改，由于不满意或需求变更，需要全部丢弃。</em></p>
<p>只需要一个指令就能清空工作目录所有修改</p>
<pre><code>git reset --hard 最近一个commitid
</code></pre><h2 id="删除远程仓库的错误提交"><a href="#删除远程仓库的错误提交" class="headerlink" title="删除远程仓库的错误提交"></a>删除远程仓库的错误提交</h2><p><em>场景：当你手贱把一个未经测试的 commit 直接 push 到远程仓库，别人只要在你这个分支下 pull<br>了代码，那就挂了。</em></p>
<p>先删除本地错误的提交</p>
<pre><code>git reset --hard HEAD~1
</code></pre><p>再提交到远程仓库</p>
<pre><code>git push origin yourbranch --force
</code></pre><p>需要注意的是，当存在多人对 yourbranch 同时进行开发的时候，以上这个 –force 操作可能会覆<br>盖掉其他人的提交记录</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;暂存当前分支代码（不提交）&quot;&gt;&lt;a href=&quot;#暂存当前分支代码（不提交）&quot; class=&quot;headerlink&quot; title=&quot;暂存当前分支代码（不提交）&quot;&gt;&lt;/a&gt;暂存当前分支代码（不提交）&lt;/h2&gt;&lt;p&gt;&lt;em&gt;场景：当你在开发分支工作，突然收到一个线上故
    
    </summary>
    
    
      <category term="git" scheme="http://0xff00.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="http://0xff00.com/2016/12/30/about-me/"/>
    <id>http://0xff00.com/2016/12/30/about-me/</id>
    <published>2016-12-30T09:09:27.000Z</published>
    <updated>2017-01-11T17:48:27.340Z</updated>
    
    <content type="html"><![CDATA[<p>不写程序的吉他手不是个老司机</p>
<p>鸡猫: kenbinglee<br>微信: 只加美妞</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不写程序的吉他手不是个老司机&lt;/p&gt;
&lt;p&gt;鸡猫: kenbinglee&lt;br&gt;微信: 只加美妞&lt;/p&gt;

    
    </summary>
    
    
      <category term="others" scheme="http://0xff00.com/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>Jekyll 迁移至 Hexo</title>
    <link href="http://0xff00.com/2016/12/30/move-to-hexo/"/>
    <id>http://0xff00.com/2016/12/30/move-to-hexo/</id>
    <published>2016-12-30T07:48:09.000Z</published>
    <updated>2017-01-11T17:48:42.430Z</updated>
    
    <content type="html"><![CDATA[<p>无意发现 hexo 的作者是 95 年的，后生可畏…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无意发现 hexo 的作者是 95 年的，后生可畏…&lt;/p&gt;

    
    </summary>
    
    
      <category term="others" scheme="http://0xff00.com/tags/others/"/>
    
  </entry>
  
</feed>
