<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0xff00</title>
  <subtitle>can&#39;t afford 0xffff</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://0xff00.com/"/>
  <updated>2017-12-18T05:09:26.827Z</updated>
  <id>http://0xff00.com/</id>
  
  <author>
    <name>kenbing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 锁模型</title>
    <link href="http://0xff00.com/2017/12/10/mysql-lock-modes/"/>
    <id>http://0xff00.com/2017/12/10/mysql-lock-modes/</id>
    <published>2017-12-09T16:31:18.000Z</published>
    <updated>2017-12-18T05:09:26.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言：何为锁？"><a href="#前言：何为锁？" class="headerlink" title="前言：何为锁？"></a>前言：何为锁？</h1><blockquote>
<p>锁是计算机协调多个进程或线程并发访问某一资源的机制</p>
</blockquote>
<p>像 CPU, 内存, I/O 这些都是资源，在现在这种多用户的操作系统中，都会被共享到，那势必涉及到用锁来协调。</p>
<p>区别于上述的物理硬件，数据亦是一种共享资源，同样需要通过锁来解决多用户，并发访问的问题，而数据库这样的应用恰恰帮我们用锁来实现上面的问题。</p>
<p>不难发现，想避免数据竞争，加锁实现串行化，一个个去操作数据是最好的方法，但是这样相当于就没有了并发，是要数据安全，还是要并发性能，这又是一个计算机领域的难题。</p>
<h1 id="MySQL-锁机制"><a href="#MySQL-锁机制" class="headerlink" title="MySQL 锁机制"></a>MySQL 锁机制</h1><p>这里以 MySQL 为例（因为我只接触过它:P），先大致了解下锁的种类，后面再看如何解决数据安全跟性能之间的权衡。</p>
<p>按锁定的数据范围，MySQL 的锁可分为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">范围</th>
<th style="text-align:center">粒度</th>
<th style="text-align:center">开销</th>
<th style="text-align:center">加锁速度</th>
<th style="text-align:center">锁冲突概率</th>
<th style="text-align:center">死锁</th>
<th style="text-align:center">并发</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">表级</td>
<td style="text-align:center">大</td>
<td style="text-align:center">小</td>
<td style="text-align:center">快</td>
<td style="text-align:center">高</td>
<td style="text-align:center">没有</td>
<td style="text-align:center">最低</td>
</tr>
<tr>
<td style="text-align:center">页级</td>
<td style="text-align:center">中</td>
<td style="text-align:center">中</td>
<td style="text-align:center">中</td>
<td style="text-align:center">中</td>
<td style="text-align:center">存在</td>
<td style="text-align:center">一般</td>
</tr>
<tr>
<td style="text-align:center">行级</td>
<td style="text-align:center">小</td>
<td style="text-align:center">大</td>
<td style="text-align:center">慢</td>
<td style="text-align:center">低</td>
<td style="text-align:center">存在</td>
<td style="text-align:center">最高</td>
</tr>
</tbody>
</table>
<p>我个人还有三个小疑问：</p>
<ol>
<li>MySQL 不是号称实现了锁机制，为何还要开发人员去管理锁？</li>
<li>如果开发人员对操作加锁，该加什么类型的锁？</li>
<li>加锁的数据范围及时间范围又该怎么定夺？</li>
</ol>
<h1 id="MyISAM-和表锁"><a href="#MyISAM-和表锁" class="headerlink" title="MyISAM 和表锁"></a>MyISAM 和表锁</h1><p>表锁分为两种：</p>
<ol>
<li>Table Read Lock</li>
<li>Table Write Lock</li>
</ol>
<h2 id="锁定关系"><a href="#锁定关系" class="headerlink" title="锁定关系"></a>锁定关系</h2><table>
<thead>
<tr>
<th style="text-align:center">锁定关系</th>
<th style="text-align:center">Read Lock</th>
<th style="text-align:center">Write Lock</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Read Lock</td>
<td style="text-align:center">并行</td>
<td style="text-align:center">互斥</td>
</tr>
<tr>
<td style="text-align:center">Write Lock</td>
<td style="text-align:center">互斥</td>
<td style="text-align:center">互斥</td>
</tr>
</tbody>
</table>
<p>简单说，除了读读是并发的，其他锁组合都是串行，需要等待上一个锁释放才能进行上锁。</p>
<h2 id="如何上锁"><a href="#如何上锁" class="headerlink" title="如何上锁"></a>如何上锁</h2><p>MyISAM 会自动操作上锁（隐式）</p>
<ol>
<li>SELECT 自动加 Read Lock</li>
<li>UPDATE/INSERT/DELETE 自动加 Write Lock</li>
</ol>
<p>那为何还要用语句 LOCK TABLE （显式）加锁呢？无非是为了模拟事务，MyISAM 是不支持事务的。</p>
<blockquote>
<p>事务是由<strong>一组 SQL 语句</strong>组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。</p>
</blockquote>
<p>因为事务一组 SQL 语句可能涉及多表，所以语句级别的隐式锁定不能满足，必须显式地 LOCK TABLE，例如有 orders 及 products 两张表，里面的 SUM(price) 正常情况下是一致的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(price) <span class="keyword">FROM</span> <span class="keyword">order</span>;</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(price) <span class="keyword">FROM</span> product;</div></pre></td></tr></table></figure>
<p>但如果不 LOCK TABLE，可能你读出 orders 的 SUM(price) 时，products 的 SUM(price) 已经改变了，可见 LOCK TABLE 在这种场景下是必要的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">LOCK</span> <span class="keyword">tables</span> orders <span class="keyword">read</span> <span class="keyword">local</span>, products <span class="keyword">read</span> <span class="keyword">local</span>;</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(price) <span class="keyword">FROM</span> <span class="keyword">order</span>;</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(price) <span class="keyword">FROM</span> product;</div><div class="line"><span class="keyword">Unlock</span> <span class="keyword">tables</span>;</div></pre></td></tr></table></figure>
<p>特别强调：</p>
<ol>
<li>local 是一个 LOCK TABLE 的一个选项，作用就是在满足 MyISAM 并发插入条件的情况下，允许其他用户在<strong>表尾插入记录</strong></li>
<li>LOCK TABLE 要一次性 LOCK 住所有要操作的表，不能访问其他一切表，如果加的是读锁，就只能执行读，而不能执行写，写锁同理</li>
<li>其他 Session 对表的锁定关系不变</li>
</ol>
<h2 id="锁并发"><a href="#锁并发" class="headerlink" title="锁并发"></a>锁并发</h2><p>在一定的条件下，MyISAM 也支持 r/w 并发，涉及到一个引擎的系统参数 (concurrent_insert)，这里不展开讲了，有兴趣自己去查文档。</p>
<h2 id="锁调度"><a href="#锁调度" class="headerlink" title="锁调度"></a>锁调度</h2><p>上面已经讲了锁定关系，读写锁是互斥的，串行的，那是不是按照先来后到的顺序？并不是！写锁的优先级要远远高过读锁！申请写锁的进程会优先上锁，这也正是 MyISAM 不太适合于有大量更新操作和查询操作应用的原因，大量的更新操作会造成查询操作很难获得读锁，读操作可能永远阻塞。</p>
<p>好在有两个系统参数可以调整读锁的优先级，这里不展开讲了，有兴趣自己去查文档。</p>
<ol>
<li>low-priority-updates</li>
<li>max_write_lock_count</li>
</ol>
<p>特别强调：</p>
<ol>
<li>避免时间长的查询语句，这样可以避免锁冲突，减少其他进程超时的情况</li>
<li>如果无法避免，就在低峰期进行操作，例如统计报表数据可放在深夜去跑</li>
</ol>
<h1 id="InnoDB-和行锁"><a href="#InnoDB-和行锁" class="headerlink" title="InnoDB 和行锁"></a>InnoDB 和行锁</h1><p>InnoDB 相比 MyISAM 最大的不同是：</p>
<ol>
<li>支持行锁</li>
<li>支持事务</li>
</ol>
<p>先说事务，上面已经提到了事务具备 ACID 属性，这几个属性势必跟并发性能是想冲突的，如果是表锁实现的事务，其实还是把事务变成串行事务，可想而知并发性能是非常之低，那么 InnoDB 是如何去权衡这两者的关系？</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92 定义了４个事务隔离级别：</p>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别/并发副作用</th>
<th style="text-align:center">读取一致性</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Read Uncommited</td>
<td style="text-align:center">只能保证读取物理数据正确</td>
<td style="text-align:center">存在</td>
<td style="text-align:center">存在</td>
<td style="text-align:center">存在</td>
</tr>
<tr>
<td style="text-align:center">Read Commited</td>
<td style="text-align:center">语句级别</td>
<td style="text-align:center">没有</td>
<td style="text-align:center">存在</td>
<td style="text-align:center">存在</td>
</tr>
<tr>
<td style="text-align:center">Repeatable Read</td>
<td style="text-align:center">事务级别</td>
<td style="text-align:center">没有</td>
<td style="text-align:center">没有</td>
<td style="text-align:center">存在</td>
</tr>
<tr>
<td style="text-align:center">Serializable</td>
<td style="text-align:center">事务级别</td>
<td style="text-align:center">没有</td>
<td style="text-align:center">没有</td>
<td style="text-align:center">没有</td>
</tr>
</tbody>
</table>
<p>隔离级别及对应的副作用<a href="http://www.jianshu.com/p/4e3edbedb9a8" target="_blank" rel="external">这篇文章</a>写得非常浅显易懂，这里就不作展开，就看他这篇即可。</p>
<p>其中，Serializable 也就是表级的串行，隔离级别最高，基本没有并发可言，而 Read Uncommited 根本不适用数据库这样的有一致性要求的场景，也基本用不到，本文不对这两种隔离级别进行讨论，主要针对 Read Commited 和 Repeatable Read 两个隔离等级进行讨论。当然还是那句老话，具体选用哪个隔离级别要结合你的应用场景！</p>
<p>为了实现上面的事务隔离级别，InnoDB 提供了四种行锁来实现：</p>
<ol>
<li>共享锁（S）</li>
<li>排它锁（X）</li>
<li>意向共享锁（IS）</li>
<li>意向排它锁（IX）</li>
</ol>
<h2 id="锁定关系-1"><a href="#锁定关系-1" class="headerlink" title="锁定关系"></a>锁定关系</h2><table>
<thead>
<tr>
<th style="text-align:center">锁定关系</th>
<th style="text-align:center">S</th>
<th style="text-align:center">X</th>
<th style="text-align:center">IS</th>
<th style="text-align:center">IX</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">并行</td>
<td style="text-align:center">互斥</td>
<td style="text-align:center">并行</td>
<td style="text-align:center">互斥</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">互斥</td>
<td style="text-align:center">互斥</td>
<td style="text-align:center">互斥</td>
<td style="text-align:center">互斥</td>
</tr>
<tr>
<td style="text-align:center">IS</td>
<td style="text-align:center">并行</td>
<td style="text-align:center">互斥</td>
<td style="text-align:center">并行</td>
<td style="text-align:center">并行</td>
</tr>
<tr>
<td style="text-align:center">IX</td>
<td style="text-align:center">互斥</td>
<td style="text-align:center">互斥</td>
<td style="text-align:center">并行</td>
<td style="text-align:center">并行</td>
</tr>
</tbody>
</table>
<p>同样，InnoDB 也是自动加锁，但也可以显式地加锁</p>
<ol>
<li>共享锁（S）：WHERE … LOCK IN SHARE MODE</li>
<li>排它锁（X）：WHERE … FOR UPDATE</li>
</ol>
<p>很多人容易搞混不可重复读和幻读，确实这两者有些相似：</p>
<ul>
<li>不可重复读在于 UPDATE 和 DELETE</li>
<li>幻读在于 INSERT。</li>
</ul>
<p>如果使用锁机制来实现这两种隔离级别，在可重复读中，该 SQL 第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住 INSERT 的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以 INSERT 数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要 Serializable 隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。</p>
<p>所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。上文说的，是使用悲观锁机制来处理这两种问题，MySQL 出于性能考虑，使用了以乐观锁为理论基础的 MVCC（多版本并发控制）来避免这两种问题。</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>人们一般把基于锁的并发控制机制称成为悲观机制，而把 MVCC 机制称为乐观机制。这是因为锁机制是一种预防性的，读会阻塞写，写也会阻塞读，当锁定粒度较大，时间较长时并发性能就不会太好；而MVCC是一种后验性的，读不阻塞写，写也不阻塞读，等到提交的时候才检验是否有冲突，由于没有锁，所以读写不会相互阻塞，从而大大提升了并发性能。</p>
<p><strong> 声明一点：Multi-Version Concurrency Control 是一种无锁事务机制，而不是一种具体的实现。 </strong></p>
<p>这里讨论的是 InnoDB 对 MVCC 的实现：</p>
<ul>
<li>SELECT时，读取创建版本号 &lt;= 当前事务版本号，删除版本号为空或 &gt; 当前事务版本号</li>
<li>INSERT时，保存当前事务版本号为行的创建版本号</li>
<li>DELETE时，保存当前事务版本号为行的删除版本号</li>
<li>UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行</li>
</ul>
<p>这样读不阻塞写，写不阻塞读，并发自然就高了，当然也取决与资源读写竞争频率，如果是高频数据，那势必会导致很多重试，万一重拾的成本非常高，那还不如用锁机制去实现。</p>
<p>首先看下 MVCC 引入的两种读：</p>
<ul>
<li><p>snapshot read (快照读): 顾名思义读取的是数据的某个历史版本，有可能不是最新的</p>
<ol>
<li>select * from table … ;</li>
</ol>
</li>
<li><p>current read (当前读): 读取的是最新的数据，在 MVCC 中需要显式去加锁</p>
<ol>
<li>select * from table … lock in share mode;</li>
<li>select * from table … for update;</li>
<li>insert/update/delete;</li>
</ol>
</li>
</ul>
<p>这里有个疑问，为何 insert/update/delete 这类写操作也归类为当前读？那是因为在 MySQL 内部，一个写操作都是需要<strong>先读取记录</strong>，再对这些记录进行操作。</p>
<p>对于读操作（快照读)：</p>
<p>RC 级别，读取的是 fresh snapshot，也就是最新的数据版本，确实存在重复读的情况。<br>RR 级别，但读取的是某个版本的 snapshot (事务中第一个读取语句发生那一刻的 snapshot)，由于历史数据是按版本为单位的，所以快照读是不存在幻读的。</p>
<p>对于写操作（当前读）：</p>
<p>回到事务隔离级别的概念上，定义中带来的副作用指的是当前读下产生的，跟 MVCC 引入的快照读不能一概而谈，当前读的隔离性必须得通过上锁来实现，而此时单单行锁是满足不了需求的，InnoDB 实现了一个叫 Next-Key 的锁来保障 RR 级别不会幻读。</p>
<p><strong>所以 InnoDB 的 RR 隔离级别是消除了幻读吗？怎么跟 ISO 的说法不一样，当然了，标准是标准，具体实现又是另一回事，这里有篇很有意思的<a href="文章">https://github.com/Yhzhtk/note/issues/42</a>记录了这一个问题，强烈推荐看一下！</strong></p>
<h2 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h2><p>Next-Key Lock = X Lock + Gap Lock</p>
<p>RC 级别，当前读会对数据加 X Lock，存在幻读。<br>RR 级别，当前读会对记录加 X Lock，同时保证对读取的范围加 Gap Lock，新的满足查询条件的记录不能够插入，不存在幻读现象。</p>
<p>再详细说明一下 Next-Key 是避免 RR 的幻读，我们知道 Record Lock 只能锁定到当前的记录，如果其他事务 Insert 了数据，就会造成幻读</p>
<p>方法一：加表锁，锁住其他事务不给 Insert （相当变为 Serialazable 级别，抛弃）</p>
<p>方法二：</p>
<p><strong>Where 条件走普通索引的情况</strong></p>
<p><img src="next-key.jpg" alt="next-key"></p>
<ol>
<li>如图所示先定位到索引的记录，加上 X 锁</li>
<li>再把索引记录两边的间隙分别加上 Gap 锁</li>
<li>再由索引定位到主键记录，再加上 X 锁</li>
</ol>
<p><strong>WHERE 条件走 Primary Key/Unique Key 的情况</strong></p>
<ol>
<li>由于这两种索引本身保证了Unique，所以新记录插不进去</li>
<li>所以只需要加上对应记录的 X 锁即可</li>
</ol>
<p><strong>WHERE 条件不走任何索引</strong></p>
<ol>
<li>扫全表，在每条主键记录上加上 Gap 锁 </li>
<li>阻塞所有需要加锁的操作</li>
<li>当然 MySQL 本身会优化这种情况，对于不满足的记录会提前释放，有兴趣的可以参考这篇<a href="http://hedengcheng.com/?p=220" target="_blank" rel="external">blog</a></li>
</ol>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>占坑，也许新开一篇来探讨…</p>
<h1 id="MetaData-Lock"><a href="#MetaData-Lock" class="headerlink" title="MetaData Lock"></a>MetaData Lock</h1><p>本文讨论的都是 CURD Data Manipulate Language (DML) 的锁，而对表结构的操作 Data Definition Language (DDL)，MySQL 会加上 MetaData Lock（MDL）。MySQL 5.3 版本后引入了MDL，只有在事务结束后才会释放 MDL，因此在事务提交或回滚前，是无法进行DDL操作的。这里先点一下，下次再写一片慢慢探讨。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>先解答文初我的三个疑问：</p>
<ol>
<li>MySQL 实现的是语句级别自动加锁，事务是涉及特定业务的多条语句，所以有自己加锁的需求</li>
<li>加锁类型也是根据事务要达成的目的，在一致性要求强的情况下可以加X锁，其他情况考虑并发可以加S锁</li>
<li>手动加锁范围会直到事务结束（不敢确定，因为还没详细了解锁升级的内容）</li>
</ol>
<p>简单来说 InnoDB 干了下面几件事：</p>
<ol>
<li>为了提高并发性能</li>
<li>提出了粒度更小的行锁</li>
<li>提出了基于事务隔离级别来平衡事务的<strong>一致性读</strong></li>
<li>利用 MVCC 来实现隔离级别中产生的读取副作用</li>
<li>从而提高了并发性能</li>
</ol>
<p>终于对 MySQL 锁机制/事务隔离级别有了个大概的了解，数据一致性及并发始终是一个难题，一个关于权衡的难题，只有深刻认识业务才能作出合适的选型。其中事务级别 RU 及 Serializable 分别是并发及一致性的两个极端，更好地帮我们去理清两个边界，最终权衡出 RC/RR 两个用处比较广泛的事务场景。</p>
<p>另外关于锁/MVCC，这两者就像是连接数据一致性和并发性能的绳子，特别是 MVCC 让我学习了另一种提升并发性能的方法。</p>
<p>最后，再称赞下 MySQL 设计的精妙，无论是提出当前读跟快照读，还是违反两段提交的提前 unlock 行数据，都是在整个理论模型上的有效补充。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://coolshell.cn/articles/6790.html" target="_blank" rel="external">https://coolshell.cn/articles/6790.html</a><br><a href="http://blog.csdn.net/chen77716/article/details/6742128" target="_blank" rel="external">http://blog.csdn.net/chen77716/article/details/6742128</a><br><a href="http://blog.csdn.net/zyz511919766/article/details/49450849" target="_blank" rel="external">http://blog.csdn.net/zyz511919766/article/details/49450849</a><br><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="external">https://tech.meituan.com/innodb-lock.html</a><br><a href="http://www.cnblogs.com/chenqionghe/p/4845693.html" target="_blank" rel="external">http://www.cnblogs.com/chenqionghe/p/4845693.html</a><br><a href="http://www.cnblogs.com/renolei/p/5910060.html" target="_blank" rel="external">http://www.cnblogs.com/renolei/p/5910060.html</a><br><a href="http://mysql.taobao.org/monthly/2016/03/10/" target="_blank" rel="external">http://mysql.taobao.org/monthly/2016/03/10/</a><br><a href="http://www.jianshu.com/p/4e3edbedb9a8" target="_blank" rel="external">http://www.jianshu.com/p/4e3edbedb9a8</a><br><a href="https://github.com/Yhzhtk/note/issues/42" target="_blank" rel="external">https://github.com/Yhzhtk/note/issues/42</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言：何为锁？&quot;&gt;&lt;a href=&quot;#前言：何为锁？&quot; class=&quot;headerlink&quot; title=&quot;前言：何为锁？&quot;&gt;&lt;/a&gt;前言：何为锁？&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;锁是计算机协调多个进程或线程并发访问某一资源的机制&lt;/p&gt;
&lt;/block
    
    </summary>
    
    
      <category term="mysql" scheme="http://0xff00.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Linux 启动流程：Systemd 圣战</title>
    <link href="http://0xff00.com/2017/11/28/linux-startup-2/"/>
    <id>http://0xff00.com/2017/11/28/linux-startup-2/</id>
    <published>2017-11-28T15:54:01.000Z</published>
    <updated>2017-12-14T15:50:17.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PID-1"><a href="#PID-1" class="headerlink" title="PID 1"></a>PID 1</h1><p>上篇说到加载完 kernel 后会 init 用户态第一个进程，PID 1，又叫超级进程，也叫根进程，它负责产生其他所有用户进程。所有的进程都会被挂在这个进程下，如果这个进程退出了，那么所有的进程都被 kill 。如果一个子进程的父进程退了，那么这个子进程会被挂到 PID 1 下面。</p>
<p>下面我们就来说说 PID 1历史上是如何启动的。</p>
<h1 id="回溯历史"><a href="#回溯历史" class="headerlink" title="回溯历史"></a>回溯历史</h1><h2 id="SysV-Init"><a href="#SysV-Init" class="headerlink" title="SysV Init"></a>SysV Init</h2><ol>
<li>产生于命令行时代</li>
<li>串行启动进程</li>
<li>一次性全部启动</li>
</ol>
<h2 id="Upstart"><a href="#Upstart" class="headerlink" title="Upstart"></a>Upstart</h2><ol>
<li>为了解决桌面时代热插拔的问题</li>
<li>基于事件驱动</li>
<li>Job/Event 的设计</li>
</ol>
<h2 id="Systemd"><a href="#Systemd" class="headerlink" title="Systemd"></a>Systemd</h2><ol>
<li>为了解决不够快的问题</li>
<li>按需启动</li>
<li>并行启动</li>
</ol>
<h3 id="如何做到快？"><a href="#如何做到快？" class="headerlink" title="如何做到快？"></a>如何做到快？</h3><ol>
<li>处理了Socket/D-bus/fs之间的依赖</li>
<li>用纯C语言代替了Shell启动脚本</li>
</ol>
<h3 id="三者启动蓝牙程序的对比"><a href="#三者启动蓝牙程序的对比" class="headerlink" title="三者启动蓝牙程序的对比"></a>三者启动蓝牙程序的对比</h3><p><img src="https://coolshell.cn/wp-content/uploads/2017/07/boot.png" alt="compare"></p>
<h3 id="除此之外"><a href="#除此之外" class="headerlink" title="除此之外"></a>除此之外</h3><ol>
<li>可以跟踪上服务进程所fork/exec出来的所有进程</li>
<li>简化了整个 daemon 开发的过程</li>
<li>自动检测启动的服务间有没有环形依赖</li>
<li>内建 autofs 自动挂载管理功能</li>
<li>改造了传统的 syslog 的问题，采用二进制格式保存日志，日志索引更快</li>
<li>快照和恢复。对当前的系统运行的服务集合做快照，并可以恢复</li>
<li>……</li>
</ol>
<p>这时候有谁出来喊了，Systemd 干了很多本不该他管的事情，于是开始有人抵制并抗议这种做法。</p>
<h1 id="圣战打响"><a href="#圣战打响" class="headerlink" title="圣战打响"></a>圣战打响</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反”keep simple, keep stupi d”的<a href="http://www.ruanyifeng.com/blog/2009/06/unix_philosophy.html" target="_blank" rel="external">Unix 哲学</a>。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030703.png" alt="arch"></p>
<h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p>起初 Systemd 的作者 Lennart 写了篇<a href="http://0pointer.de/blog/projects/the-biggest-myths.html" target="_blank" rel="external">文章</a>解释大众对 Systemd 的误解，但丝毫不起作用，并且在网络上招受到大量的语言暴力，甚至收到死亡威胁邮件。</p>
<p>于是 Lennart 写了篇<a href="https://plus.google.com/+LennartPoetteringTheOneAndOnly/posts/J2TZrTvu7vd" target="_blank" rel="external">帖子</a>来抨击 Linux 社区及 Linus 本人，说 Linus 领导的 Linux 组织已经是一个彻头彻尾的邪教。</p>
<p>随后，Linus 在有一次采访中也对此发表了自己的看法，大意如下图。</p>
<p><img src="https://cdn.arstechnica.net/wp-content/uploads/2013/02/linus-eff-you-640x363.png" alt="fuck"></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>目前几乎所有Linux发行版都用 Systemd 来启动及管理进程。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h3 id="systemdt-的-pstree"><a href="#systemdt-的-pstree" class="headerlink" title="systemdt 的 pstree"></a>systemdt 的 pstree</h3><p><img src="https://www.daehub.com/wp-content/uploads/2016/12/pstree-result.jpg" alt="systemd"></p>
<h3 id="init-的-pstree"><a href="#init-的-pstree" class="headerlink" title="init 的 pstree"></a>init 的 pstree</h3><p><img src="http://images2017.cnblogs.com/blog/1102349/201707/1102349-20170727195008415-1871371589.png" alt="init"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://coolshell.cn/articles/17998.html" target="_blank" rel="external">https://coolshell.cn/articles/17998.html</a><br><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a><br><a href="http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PID-1&quot;&gt;&lt;a href=&quot;#PID-1&quot; class=&quot;headerlink&quot; title=&quot;PID 1&quot;&gt;&lt;/a&gt;PID 1&lt;/h1&gt;&lt;p&gt;上篇说到加载完 kernel 后会 init 用户态第一个进程，PID 1，又叫超级进程，也叫根进程，它负责产生其他
    
    </summary>
    
    
      <category term="systemd" scheme="http://0xff00.com/tags/systemd/"/>
    
  </entry>
  
  <entry>
    <title>Linux 启动流程：硬件通电到加载内核</title>
    <link href="http://0xff00.com/2017/10/09/linux-startup-1/"/>
    <id>http://0xff00.com/2017/10/09/linux-startup-1/</id>
    <published>2017-10-09T02:35:27.000Z</published>
    <updated>2017-12-14T15:49:04.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>继 TAB VS SPACE，VIM VS EMACS 等程序员的圣战后，最近又接触了一场新的圣战：systemd VS sysvinit</p>
<p>讲的是 Linux 如何启动第一个程序(PID:1)， 本想先说下这一段历史渊源，发现有必要先讲下计算机是如何 boot 起来，所以本篇是个姐妹篇，我们先来聊聊计算机是如何启动的，下篇再来回顾这场圣战！</p>
<h1 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h1><p>这个启动顺序是每次开机都会看到的，不管是 Linux 还是 Windows：</p>
<p><img src="http://7xjdax.com1.z0.glb.clouddn.com/blogfigure1.gif" alt="boot-sequence"></p>
<h1 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h1><p>首先当你按下 power 键，主机通电了，第一个相应的器件是什么呢？（别说是电源或风扇…）答案是这块东西！</p>
<p><img src="http://www.bcwork.cn/uploadfile/201105/1/7F83244225.jpg" alt="bios-chips"></p>
<p>他是一块 ROM，由主板厂商焊死在板上，存放着开机来第一个系统：基本输入输出系统！Basic Input Output System！！BIOS！！！</p>
<p>所以 BIOS 到底干嘛的？？？说白它就干两件事</p>
<ol>
<li>检查硬件能否满足运行的基本条件（CPU, 内存, 硬盘…）</li>
<li>if not OK，主板会发出不同含义的蜂鸣，启动中止</li>
<li>if OK，屏幕就会显示出CPU、内存、硬盘等信息，并把控制权转交给下一阶段的启动程序</li>
</ol>
<h1 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h1><p>下一阶段的启动程序，那他肯定不是放在 CPU（计算单元），内存（易失性存储器），所以只能是非易失性存储器里了，那可以是 U盘，光碟，或者通常的硬盘（听到硬盘通常都会稍微硬一下以示敬意）这里拿最便宜的机械硬盘来说。</p>
<p>硬盘这么大，哪去找“下一阶段的启动程序”，既然上一步 BIOS 没对 CPU 说，那就只能拿第一个能拿到的区域，就机械硬盘而言，就是第一个扇区了，也就是最开始的 512 个字节，但并不是每一个硬盘的第一个扇区都能启动，它必须是以 0x55, 0xAA 这两个字节结尾的扇区才可以，我们把这种特殊的扇区叫做“主引导记录”！Master Boot Record！！MBR！！！</p>
<p>MBR 只有512个字节，放不了太多东西。它的主要作用是，<strong>告诉计算机到硬盘的哪一个位置去找操作系统！</strong></p>
<p><img src="http://7xjdax.com1.z0.glb.clouddn.com/blogfigure2.gif" alt="mbr"></p>
<p>上图可见一个硬盘只能分为4个分区，并且必须有且只有一个主分区！叫做”卷引导记录”！Volume boot record！！VBR！！！</p>
<p>但随着有些人喜欢分（系统，学习，工作，音乐，电影，图片，备份1，备份2…）等超过4个分区，MBR 已经满足不了了，所以后来规定了有且只有一个分区设置为“扩展引导记录”！Extended boot record！！EBR！！！（又来一个，我快记不住了）</p>
<p>EBR 包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。<br>计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项），因此，扩展分区可以包含无数个逻辑分区，到此，PROBLEMS SOLVED！</p>
<p>但是，现在没人这么用了，这段为何不用这两种启动方式的历史我懒得去找，反正我从小就是用以下即将要讲的方式！！！</p>
<h1 id="GRUB"><a href="#GRUB" class="headerlink" title="GRUB"></a>GRUB</h1><p>这种方式就是，计算机读取”主引导记录”前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统，Linux环境中，目前最流行的启动管理器是GRUB:</p>
<p><img src="http://www.supergrubdisk.org/wp-content/uploads/2013/11/rescatux_wizard_grub_menu.png" alt="grub"></p>
<p>由用户选择进入哪一个操做系统</p>
<h1 id="Linux-Kernel"><a href="#Linux-Kernel" class="headerlink" title="Linux Kernel"></a>Linux Kernel</h1><p>至此，控制权转交给操作系统后，操作系统的内核首先被载入内存，以Linux系统为例，先载入/boot目录下面的kernel，内核加载完成后，讲启动系统第一个进程（pid:1），其他进程都是它的后代。</p>
<h1 id="init（圣战战场）"><a href="#init（圣战战场）" class="headerlink" title="init（圣战战场）"></a>init（圣战战场）</h1><p>且听下回分解</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://huaqianlee.github.io/2015/08/21/Linux/深入理解Linux启动过程" title="深入理解Linux启动过程" target="_blank" rel="external">http://huaqianlee.github.io/2015/08/21/Linux/深入理解Linux启动过程 /</a><br><a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html" title="linux_boot_process" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;继 TAB VS SPACE，VIM VS EMACS 等程序员的圣战后，最近又接触了一场新的圣战：systemd VS sysvinit&lt;
    
    </summary>
    
    
      <category term="linux" scheme="http://0xff00.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>基于 Redis HyperLogLog 的基数统计</title>
    <link href="http://0xff00.com/2017/09/15/hyperloglog/"/>
    <id>http://0xff00.com/2017/09/15/hyperloglog/</id>
    <published>2017-09-15T10:13:58.000Z</published>
    <updated>2017-10-11T12:29:22.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经过上次的教训，这次不写那么多前言了。</p>
<h1 id="什么是基数"><a href="#什么是基数" class="headerlink" title="什么是基数"></a>什么是基数</h1><blockquote>
<p>一个集合中不同元素的个数</p>
</blockquote>
<p>看两个简单的例子<br>{1，2，3，4，1，2，3}<br>{apple, banana, peach, app1e, banana}</p>
<h1 id="基数统计应用场景"><a href="#基数统计应用场景" class="headerlink" title="基数统计应用场景"></a>基数统计应用场景</h1><ol>
<li>网站首页的独立访问量</li>
<li>商品的独立访问量</li>
<li>广告的独立受众人数</li>
</ol>
<h1 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h1><p>运用<strong>第一性原理</strong>我们知道最基本的步骤是</p>
<ol>
<li>存储</li>
<li>比较</li>
</ol>
<h1 id="业界普遍使用的方案"><a href="#业界普遍使用的方案" class="headerlink" title="业界普遍使用的方案"></a>业界普遍使用的方案</h1><h2 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h2><p><img src="http://upload-images.jianshu.io/upload_images/277519-2bfcc3f69415085c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bitmap"></p>
<p>优点：</p>
<ol>
<li>那是非常简单</li>
</ol>
<p>缺点：</p>
<ol>
<li>分配的内存取决于统计最大的数</li>
</ol>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/3/33/B_tree_insertion_example.png" alt="btree"></p>
<p>优点：</p>
<ol>
<li>插入效率高</li>
<li>查找效率高</li>
<li>空间复杂度不高</li>
</ol>
<p>缺点：</p>
<ol>
<li>随着数据量变大存储空间变大</li>
<li>不能高效地合并两棵B树</li>
</ol>
<h1 id="Redis实现的方案"><a href="#Redis实现的方案" class="headerlink" title="Redis实现的方案"></a>Redis实现的方案</h1><h2 id="Set-数据结构"><a href="#Set-数据结构" class="headerlink" title="Set 数据结构"></a>Set 数据结构</h2><p>我们知道 redis set 结构本身具备了去重的功能，所以只要把元素<br>sadd uv 192.168.1.1<br>(疯狂地sadd…)<br>scard uv<br>搞定！</p>
<p>优点：</p>
<ol>
<li>高效</li>
</ol>
<p>缺点：</p>
<ol>
<li>空间随数量增大而增大</li>
</ol>
<p>所以到底增加多少？已独立IP为例</p>
<table>
<thead>
<tr>
<th>数量</th>
<th>一天</th>
<th>一月</th>
<th>一年</th>
</tr>
</thead>
<tbody>
<tr>
<td>一百万</td>
<td>15 MB</td>
<td>450 MB</td>
<td>5.4 GB</td>
</tr>
<tr>
<td>一千万</td>
<td>150 MB</td>
<td>4.5 GB</td>
<td>54 GB</td>
</tr>
<tr>
<td>一亿</td>
<td>1.5 GB</td>
<td>45 GB</td>
<td>540 GB</td>
</tr>
</tbody>
</table>
<p>至此，无论是 bitmap, B树，还是 Redis set 结构</p>
<ol>
<li>都是精确统计，因为会存储每一个元素</li>
<li>使用空间基本都是跟元素数量成正比</li>
</ol>
<p>那么，有没有一种可能不需要绝对精确，并且存储空间不随元素成正比的？</p>
<h2 id="HyperLogLog-数据结构"><a href="#HyperLogLog-数据结构" class="headerlink" title="HyperLogLog 数据结构"></a>HyperLogLog 数据结构</h2><p>当然有，就是楼上了！</p>
<blockquote>
<p>Available since 2.8.9.</p>
</blockquote>
<p>关于命名：简单说一下，有一种统计算法叫做 loglog counting，有人在这个基础上改进了，所以叫 Hyperloglog counting</p>
<p>关于原理：我还没看懂，只知道它是一个基于<strong>统计原理</strong>的基数统计方法，有兴趣可以自行维基，这里只讲 redis 中它的用法</p>
<blockquote>
<p>pfadd key element [element …]<br>命令的复杂度为 O(N) ，N 为被添加元素的数量</p>
<p>pfcount key [key …]<br>当命令作用于单个 HLL 时， 复杂度为 O(1) ， 并且具有非常低的平均常数时间<br>当命令作用于多个 HLL 时， 复杂度为 O(N) ，并且常数时间也比处理单个 HLL 时要大得多</p>
<p>pfmerge destkey sourcekey [sourcekey …]<br>命令的复杂度为 O(N) ， 其中 N 为被合并的 HLL 数量，不过这个命令的常数复杂度比较高</p>
</blockquote>
<p><strong>优点</strong></p>
<p>即使元素的数量或者体积非常非常大，HLL 所需的空间总是固定的，并且是很小的，在 Redis 里面，每个 HLL 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数</p>
<p><strong>缺点</strong></p>
<p>由于 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像 Set 那样，返回输入的各个元素</p>
<p>下面看下用 HLL 统计独立 IP 的数据</p>
<table>
<thead>
<tr>
<th>数量</th>
<th>一天</th>
<th>一月</th>
<th>一年</th>
</tr>
</thead>
<tbody>
<tr>
<td>一百万</td>
<td>12 KB</td>
<td>360 KB</td>
<td>4.32 MB</td>
</tr>
<tr>
<td>一千万</td>
<td>12 KB</td>
<td>360 KB</td>
<td>4.32 MB</td>
</tr>
<tr>
<td>一亿</td>
<td>12 KB</td>
<td>360 KB</td>
<td>4.32 MB</td>
</tr>
</tbody>
</table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>空间及时间是计算机领域永远的主题</li>
<li>还是要看业务场景！！！</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://chenjiehua.me/database/hyperloglog-bigdata.html" target="_blank" rel="external">https://chenjiehua.me/database/hyperloglog-bigdata.html</a><br><a href="http://www.cnblogs.com/ysuzhaixuefei/p/4052110.html" target="_blank" rel="external">http://www.cnblogs.com/ysuzhaixuefei/p/4052110.html</a><br><a href="http://blog.codinglabs.org/articles/algorithms-for-cardinality-estimation-part-i.html" target="_blank" rel="external">http://blog.codinglabs.org/articles/algorithms-for-cardinality-estimation-part-i.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;经过上次的教训，这次不写那么多前言了。&lt;/p&gt;
&lt;h1 id=&quot;什么是基数&quot;&gt;&lt;a href=&quot;#什么是基数&quot; class=&quot;headerl
    
    </summary>
    
    
      <category term="hyperloglog" scheme="http://0xff00.com/tags/hyperloglog/"/>
    
  </entry>
  
  <entry>
    <title>幂等提交</title>
    <link href="http://0xff00.com/2017/09/07/idempotence-submit/"/>
    <id>http://0xff00.com/2017/09/07/idempotence-submit/</id>
    <published>2017-09-07T07:49:54.000Z</published>
    <updated>2017-10-11T12:38:07.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在业务开发中，我们常会面对防止重复请求的问题。当服务端对于请求的响应涉及数据的修改，或状态的变更时，可能会造成极大的危害。特别是交易系统，售后维权，以及支付系统中尤其严重。前台操作的抖动，快速操作，网络通信或者后端响应慢，都会增加后端重复处理的概率。</p>
<p>当然，前端能屏蔽掉重复请求（真的可以吗？前端同学回答下）你也无法逃避 timeout 这个噩梦，所以，既然重复提交无法避免，那我们就从其他地方入手，先看下一些简单的需求场景：</p>
<ol>
<li>前端重复提交选中的数据，应该后台只产生对应这个数据的一个反应结果；</li>
<li>我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱；</li>
<li>发送消息，也应该只发一次，同样的短信发给用户，用户会哭的；</li>
</ol>
<p>既然调用方不靠谱，网络不靠谱，那么接口提供方就必须靠谱，允许你多次调用，我的接口都能handle，这种能力就叫幂等性。</p>
<h1 id="幂等接口"><a href="#幂等接口" class="headerlink" title="幂等接口"></a>幂等接口</h1><p>幂等是一个数学概念（摘自维基百科）</p>
<blockquote>
<ul>
<li>在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。例如，乘法下唯一两个幂等实数为0和1。</li>
<li>某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的。</li>
<li>一元运算的定义是二元运算定义的特例。</li>
</ul>
</blockquote>
<p>相应地，在计算机领域，如果一个接口一次调用或多次调用的结果是一样的，那么这个接口就是幂等的。但是我没看到一个很严谨的解释，毕竟是延伸过来的说法。</p>
<p>所以还是列举下一些常见的幂等接口：</p>
<ol>
<li>HTTP GET</li>
<li>SQL SELECT</li>
<li>大家补充…</li>
</ol>
<p>不是幂等的接口</p>
<ol>
<li>HTTP POST</li>
<li>SQL UPDATE</li>
<li>大家补充…</li>
</ol>
<p>从这些简单的例子，我大胆归结下<strong>计算机领域</strong>的<strong>幂等性</strong>是：</p>
<ol>
<li>一次调用或多次调用对系统影响是一样的</li>
<li>接口返回的结果也是一样的（不受接口调用之外的影响）</li>
</ol>
<p>好了，说完接口的幂等性，它能防止重复提交，接下来讲讲一些经典的实现方案及适用场景。</p>
<h2 id="token校验"><a href="#token校验" class="headerlink" title="token校验"></a>token校验</h2><p>由 server 产生，并且存一份，再埋在form/cookies/header;<br>client 下次请求带上 token, server 校验通过后刷新 token，执行业务；</p>
<p>优点：client 改动很小甚至不需要改动<br>缺点：无法支持 client 并发请求<br>其他讨论：server如何存储token/如果用缓存如何设置key</p>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>通过把并发问题变成串行问题，如何实现很简单</p>
<ol>
<li>数据库去重表</li>
<li>redis 原子性</li>
<li>MQ</li>
</ol>
<h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><p><em>乐观锁</em><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">update</span> table_xxx <span class="keyword">set</span> <span class="keyword">col</span>=col_xxx, ver=ver+<span class="number">1</span> <span class="keyword">where</span> ver=ver</div></pre></td></tr></table></figure></p>
<p><em>悲观锁</em><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_xxx <span class="keyword">where</span> <span class="keyword">id</span> = id_xxx <span class="keyword">for</span> <span class="keyword">update</span></div></pre></td></tr></table></figure></p>
<p>具体哪种看业务对更新成本及更新频率的考量。</p>
<h2 id="状态机幂等"><a href="#状态机幂等" class="headerlink" title="状态机幂等"></a>状态机幂等</h2><p>当业务涉及到多个状态更改，如下单支付，广告创建，可以给每一步递增标记，只允许提交大于当前标记的请求，然后每一步的幂等由上诉几种方案实现。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>防止重复提交跟保障一致性相似，要看场景，没必要强求。</li>
<li>幂等性应该列入程序员必备知识，特别是做 web 开发的程序员。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.hollischuang.com/archives/934" target="_blank" rel="external">深入理解乐观锁与悲观锁</a><br><a href="http://825635381.iteye.com/blog/2276077" target="_blank" rel="external">高并发的核心技术-幂等的实现方案</a><br><a href="http://yongpoliu.com/idempotent/" target="_blank" rel="external">系统幂等以及常用实现方式</a><br><a href="http://mogu.io/prevent-duplicate-requests-4/comment-page-1#comments" target="_blank" rel="external">防重复请求处理的实践与总结</a><br><a href="https://www.zhihu.com/question/27744795" target="_blank" rel="external">分布式高并发系统如何保证对外接口的幂等性</a><br><a href="http://geyifan.cn/2016/06/02/idempotent-solutions/" target="_blank" rel="external">幂等策略分析</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在业务开发中，我们常会面对防止重复请求的问题。当服务端对于请求的响应涉及数据的修改，或状态的变更时，可能会造成极大的危害。特别是交易系统，售
    
    </summary>
    
    
      <category term="idempotence" scheme="http://0xff00.com/tags/idempotence/"/>
    
  </entry>
  
  <entry>
    <title>被浏览器缓存策略折腾的一天</title>
    <link href="http://0xff00.com/2017/07/05/browser-cache/"/>
    <id>http://0xff00.com/2017/07/05/browser-cache/</id>
    <published>2017-07-05T07:34:13.000Z</published>
    <updated>2017-09-07T07:49:10.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="故事背景…"><a href="#故事背景…" class="headerlink" title="故事背景…"></a>故事背景…</h1><p>昨天，遇到 facebook CDN 图片一个缓存策略问题，发现自己 HTTP 缓存的相关知识都忘差不多了，必须整理一下，好，整理完再看那个问题，卧槽，缓存行为完全跟规范说的不一样，求知心强烈的我陷入了 Block 模式，开始折腾这一奇怪的现象。</p>
<p>@Todo</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;故事背景…&quot;&gt;&lt;a href=&quot;#故事背景…&quot; class=&quot;headerlink&quot; title=&quot;故事背景…&quot;&gt;&lt;/a&gt;故事背景…&lt;/h1&gt;&lt;p&gt;昨天，遇到 facebook CDN 图片一个缓存策略问题，发现自己 HTTP 缓存的相关知识都忘差不多了，必须整理
    
    </summary>
    
    
      <category term="http" scheme="http://0xff00.com/tags/http/"/>
    
      <category term="cache" scheme="http://0xff00.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>分布式笔记整理</title>
    <link href="http://0xff00.com/2017/06/26/CAP/"/>
    <id>http://0xff00.com/2017/06/26/CAP/</id>
    <published>2017-06-26T14:59:59.000Z</published>
    <updated>2017-09-07T10:39:15.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式系统定义"><a href="#分布式系统定义" class="headerlink" title="分布式系统定义"></a>分布式系统定义</h1><p>想象有这样一台计算机：</p>
<ol>
<li>极其高速的CPU</li>
<li>极其宽大的总线</li>
<li>极其大容量的内存</li>
<li>极其大带宽的网卡</li>
<li>极其稳定的组合在一起</li>
<li>再连接上一条及其稳定的线路</li>
</ol>
<p>我觉得即使再贵，买这样一台单机处理能力极其强劲的服务器就可以满足大多数应用场景，可是没有，所以才有了分布式。</p>
<p>分布式是个很广泛的话题，从我十年前我刚上大学到现在，伴随着大数据及云服务，一直保持着热度，先来看看分布式系统的定义，摘自《分布式系统概念与设计》。</p>
<blockquote>
<p>分布式系统是一个硬件或软件组件分布在<strong>不同的网络计算机</strong>上，彼此之间仅仅通过<strong>消息传递</strong>进行通信和协调的系统。</p>
</blockquote>
<p>可以看出一个分布式系统应该具备：</p>
<p><strong>某博主的看法</strong></p>
<ol>
<li>分布性</li>
<li>对等性（kb注：保持疑虑，下文有讨论）</li>
<li>并发性</li>
<li>缺乏全局时钟</li>
<li>故障总是会发生</li>
</ol>
<p><strong>我的看法（再次提一下第一性原理 ;P）</strong></p>
<ol>
<li>多机</li>
<li>网络</li>
</ol>
<h2 id="解决哪些问题"><a href="#解决哪些问题" class="headerlink" title="解决哪些问题"></a>解决哪些问题</h2><ol>
<li>单机处理能力差</li>
<li>单点故障</li>
</ol>
<h2 id="带来哪些问题"><a href="#带来哪些问题" class="headerlink" title="带来哪些问题"></a>带来哪些问题</h2><ol>
<li>通信异常</li>
<li>三态 (Success/Failure/Timeout)</li>
<li>网络分区</li>
<li>节点故障</li>
</ol>
<p><strong>总的来说：网络是不稳定的！</strong></p>
<h2 id="讨论下一个场景？"><a href="#讨论下一个场景？" class="headerlink" title="讨论下一个场景？"></a>讨论下一个场景？</h2><ol>
<li>数据分区</li>
<li>数据冗余</li>
</ol>
<p><strong>问题：哪个才算分布式？</strong></p>
<h1 id="分布式系统分类"><a href="#分布式系统分类" class="headerlink" title="分布式系统分类"></a>分布式系统分类</h1><p>按我粗浅的认知，分布式系统可以归为两大类</p>
<ol>
<li>分布式计算系统</li>
<li>分布式存储系统（数据的分布及同步问题）</li>
</ol>
<p>由于对分布式计算领域缺乏了解，本文讨论范围多以分布式存储为背景。</p>
<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p>提到分布式，不得不提这三个特性：</p>
<ul>
<li><strong>C</strong>onsistency: Every read receives the most recent write or an error</li>
<li><strong>A</strong>vailability: Every request receives a (non-error) response</li>
<li><strong>P</strong>artition tolerance: The system continues to operate despite an arbitrary number of messages being dropped or delayed by the network between nodes</li>
</ul>
<p>在分布式系统中，三者不能同时满足。这就是 CAP 理论，简单地说就是：</p>
<ul>
<li>要想让数据避免单点故障，就得写多份数据（保证P）</li>
<li>写多份的问题会导致数据一致性的问题（导致C）</li>
<li>数据一致性的问题又会引发性能问题（导致A）</li>
</ul>
<p>要如何衡量取哪两者呢？看看下面这张图，产生了三个交叉系统</p>
<p><img src="cap.png" alt="cap cross"></p>
<ol>
<li>CA 放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择</li>
<li>AP 放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多 NoSQL 系统就是如此</li>
<li>CP 放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用</li>
</ol>
<p>结合分布式的特征，我们单独分析下三者的适用场景：</p>
<ul>
<li>P 是每个分布式系统基本的特征，必须保证，无法避免</li>
<li>A 是整个系统性能的考量，谁会用一个龟速还可能要超时重连的系统</li>
<li>C 这里强调的是强一致性，现实中强一致性的需求很少，只好在一致性上做妥协</li>
</ul>
<p><strong>所以在我看来</strong>，更通用的分布式系统要满足AP。</p>
<h1 id="分布式ACID"><a href="#分布式ACID" class="headerlink" title="分布式ACID"></a>分布式ACID</h1><p>ACID 在单机上，或者CP模型下实现起来是不难的，但前者是单点，后者更是损失了A，所以分布式事<br>物是整个分布式领域无法逃避的难题，下面就分布式事务的实现，从简陋到严谨，层层递进，试着阐<br>述行业内的一些解决策略。</p>
<h2 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h2><p>首先我们对C做个分类，上文提到，现实中对强一致性需求不大，我们把一致性拆解为一下三种模型：</p>
<ol>
<li>Weak 弱一致性：当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。比如：某些 cache 系统，网络游戏其它玩家的数据和你没什么关系，VOIP 这样的系统，或是百度搜索引擎呵呵（kb注：陈皓原话）。</li>
<li>Eventually 最终一致性：当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件、Amazon S3，Google 搜索引擎这样的系统。</li>
<li>Strong 强一致性：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，Azure Table 都是强一致性的。</li>
</ol>
<p>从这三种一致型的模型上来说，我们可以看到，Weak 和 Eventually 一般来说是异步冗余的，而 Strong 一般来说是同步冗余的，异步的通常意味着更好的性能，但也意味着更复杂的状态控制。同步意味着简单，但也意味着性能下降。先大概让我们来看看有哪些策略：</p>
<ul>
<li>Master-Slave</li>
<li>Master-Master</li>
<li>2PC/3PC</li>
<li>Two Generals Problem</li>
<li>Paxos/Raft</li>
</ul>
<p>一致性模型的说明，陈皓在<a href="http://coolshell.cn/articles/10910.html" title="CoolShell" target="_blank" rel="external">这篇博文</a>中已经阐述得非常清楚，强烈建议看一看！附上结论图：</p>
<p><img src="stragety_of_consistency.jpg" alt="stragety of consistency"></p>
<p>前面说过，要想让数据有高可用性，就需要冗余数据写多份。写多份的问题会带来一致性的问题，而一致性的问题又会带来性能问题。从上图我们可以看到，我们基本上来说不可以让所有的项都绿起来，这就是著名的CAP理论：一致性，可用性，分区容忍性，你只可能要其中的两个。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此，一切还是遵循着 CAP 理论，但是，据说，Google 新发布的 Spanner 关系型 NoSQL 已经打破了 CAP，欲知详情，且听下回分解，或者，你现在就可以 google 一下。</p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="https://en.wikipedia.org/wiki/Eventual_consistency" title="BASE" target="_blank" rel="external">https://en.wikipedia.org/wiki/Eventual_consistency</a><br><a href="https://en.wikipedia.org/wiki/CAP_theorem" title="CAP" target="_blank" rel="external">https://en.wikipedia.org/wiki/CAP_theorem</a><br><a href="http://coolshell.cn/articles/10910.html" title="CoolShell" target="_blank" rel="external">http://coolshell.cn/articles/10910.html</a><br><a href="http://wuchong.me/blog/2014/08/07/distributed-storage-system-knowledge/" title="Jark&#39;s Blog" target="_blank" rel="external">http://wuchong.me/blog/2014/08/07/distributed-storage-system-knowledge/</a><br><a href="http://www.cnblogs.com/xrq730/p/4944768.html" title="五月的仓颉" target="_blank" rel="external">http://www.cnblogs.com/xrq730/p/4944768.html</a><br><a href="http://www.jianshu.com/p/6cb8ffce7510" title="JeffBond" target="_blank" rel="external">http://www.jianshu.com/p/6cb8ffce7510</a><br><a href="http://thesecretlivesofdata.com/raft/" title="Raft动态演示" target="_blank" rel="external">http://thesecretlivesofdata.com/raft/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式系统定义&quot;&gt;&lt;a href=&quot;#分布式系统定义&quot; class=&quot;headerlink&quot; title=&quot;分布式系统定义&quot;&gt;&lt;/a&gt;分布式系统定义&lt;/h1&gt;&lt;p&gt;想象有这样一台计算机：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;极其高速的CPU&lt;/li&gt;
&lt;li&gt;极其宽大的总线
    
    </summary>
    
    
      <category term="distributed" scheme="http://0xff00.com/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>有用但不常用的git指令</title>
    <link href="http://0xff00.com/2017/01/11/git-tips/"/>
    <id>http://0xff00.com/2017/01/11/git-tips/</id>
    <published>2017-01-11T15:26:24.000Z</published>
    <updated>2017-03-20T01:15:24.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="暂存当前分支代码（不提交）"><a href="#暂存当前分支代码（不提交）" class="headerlink" title="暂存当前分支代码（不提交）"></a>暂存当前分支代码（不提交）</h2><p><em>场景：当你在开发分支工作，突然收到一个线上故障，需要立刻新建一个 hotfix 分支去修复，但是<br>开发分支的代码才写了一半，你不希望提交，但是强制切去 hotfix 分支又会丢失当前的代码。</em></p>
<p>这时候可以把工作目录的修改暂存起来</p>
<pre><code>git stash
</code></pre><p>当你处理完故障切换回原来分支继续干活，恢复刚刚上一次暂存的记录</p>
<pre><code>git stash apply 
</code></pre><p>又或者恢复并从暂存区删除上一次暂存的记录</p>
<pre><code>git stash pop 
</code></pre><p>另外，你可以查看暂存列表</p>
<pre><code>git stash list
</code></pre><p>恢复指定第2个暂存记录</p>
<pre><code>git stash apply stash@{2}
</code></pre><h2 id="清空工作目录的修改"><a href="#清空工作目录的修改" class="headerlink" title="清空工作目录的修改"></a>清空工作目录的修改</h2><p><em>场景：当你在工作目录做一些修改，由于不满意或需求变更，需要全部丢弃。</em></p>
<p>只需要一个指令就能清空工作目录所有修改</p>
<pre><code>git reset --hard 最近一个commitid
</code></pre><h2 id="删除远程仓库的错误提交"><a href="#删除远程仓库的错误提交" class="headerlink" title="删除远程仓库的错误提交"></a>删除远程仓库的错误提交</h2><p><em>场景：当你手贱把一个未经测试的 commit 直接 push 到远程仓库，别人只要在你这个分支下 pull<br>了代码，那就挂了。</em></p>
<p>先删除本地错误的提交</p>
<pre><code>git reset --hard HEAD~1
</code></pre><p>再提交到远程仓库</p>
<pre><code>git push origin yourbranch --force
</code></pre><p>需要注意的是，当存在多人对 yourbranch 同时进行开发的时候，以上这个 –force 操作可能会覆<br>盖掉其他人的提交记录</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;暂存当前分支代码（不提交）&quot;&gt;&lt;a href=&quot;#暂存当前分支代码（不提交）&quot; class=&quot;headerlink&quot; title=&quot;暂存当前分支代码（不提交）&quot;&gt;&lt;/a&gt;暂存当前分支代码（不提交）&lt;/h2&gt;&lt;p&gt;&lt;em&gt;场景：当你在开发分支工作，突然收到一个线上故
    
    </summary>
    
    
      <category term="git" scheme="http://0xff00.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="http://0xff00.com/2016/12/30/about-me/"/>
    <id>http://0xff00.com/2016/12/30/about-me/</id>
    <published>2016-12-30T09:09:27.000Z</published>
    <updated>2017-01-11T17:48:27.340Z</updated>
    
    <content type="html"><![CDATA[<p>不写程序的吉他手不是个老司机</p>
<p>鸡猫: kenbinglee<br>微信: 只加美妞</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不写程序的吉他手不是个老司机&lt;/p&gt;
&lt;p&gt;鸡猫: kenbinglee&lt;br&gt;微信: 只加美妞&lt;/p&gt;

    
    </summary>
    
    
      <category term="others" scheme="http://0xff00.com/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>Jekyll 迁移至 Hexo</title>
    <link href="http://0xff00.com/2016/12/30/move-to-hexo/"/>
    <id>http://0xff00.com/2016/12/30/move-to-hexo/</id>
    <published>2016-12-30T07:48:09.000Z</published>
    <updated>2017-01-11T17:48:42.430Z</updated>
    
    <content type="html"><![CDATA[<p>无意发现 hexo 的作者是 95 年的，后生可畏…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无意发现 hexo 的作者是 95 年的，后生可畏…&lt;/p&gt;

    
    </summary>
    
    
      <category term="others" scheme="http://0xff00.com/tags/others/"/>
    
  </entry>
  
</feed>
